# Firelet - Distributed firewall management.
# Copyright (C) 2010 Federico Ceratto
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from os import listdir
from json import dumps
import shutil

from firelet import mailer
from firelet.flcore import *
from firelet.flssh import SSHConnector, MockSSHConnector
from firelet.flmap import draw_svg_map
from firelet.flutils import flag, Bunch, get_rss_channels
from nose.tools import assert_raises, with_setup
from pprint import pformat
from tempfile import mkdtemp

from firelet import cli
from firelet.cli import main as cli_main

import logging
log = logging.getLogger(__name__)

#TODO: migration to network objects
#TODO: parallel SSH
#TODO: SSH check and deployment

# Summary of tests:
#
# User Management
# File load/save
# GitFireSet
#
# CLI
# IP address manipulation
# cartesian product
#


repodir = None

# setup and teardown

def setup_dir():
    global repodir
    if repodir:
        teardown_dir()
    repodir = mkdtemp(prefix='tmp_fltest') + '/temp'
    # copytree cannot copy to existing directories, hence the /temp
    shutil.copytree('test', repodir)
    li = listdir(repodir)
    assert len(li) > 5
    log.debug("temp dir %s created" % repodir)

def teardown_dir():
    global repodir
    if repodir:
        repodir = repodir[:-5]
        shutil.rmtree(repodir)
        repodir = None

# utility functions

def string_in_list(s, li):
    """Count how many times a string is contained in a list of strings
    No exact match is required
    >>> strings_in_list('p', ['apple'])
    1
    """
    return sum((1 for x in li if s in str(x)))

def test_string_in_list():
    li = ['apple', 'p', '', None, 123, '   ']
    assert string_in_list('p', li) == 2

def assert_equal_line_by_line(li1, li2):
    for x, y in zip(li1, li2):
        assert x == y, "'%s' differs from '%s' in:\n%s\n%s\n" % (repr(li1), repr(li2))

def debug(s, o=None):
    """Log an object representation"""
    try:
        d = dumps(o, indent=2)
    except:
        d = repr(o)
    li = d.split('\n')
    if len(li) < 3:
        log.debug("%s: %s" % (s, repr(o)))
    else:
        indented = "\n    ".join(li)
        log.debug("-------- [%s] ---------\n    %s" % (s, indented))
        log.debug("----- [end of %s] -----" % s)


# #  Testing flssh module without network interaction # #

def test_parse_iptables_save_1():
    sx = MockSSHConnector(targets={'localhost':['127.0.0.1']})
    assert_raises(Exception, sx.parse_iptables_save, '')

def test_parse_iptables_save_2():
    sx = MockSSHConnector(targets={'localhost':['127.0.0.1']})
    ret = sx.parse_iptables_save("""
# Generated by iptables-save v1.4.9 on Sun Feb 20 15:04:36 2011
*filter
:INPUT ACCEPT [36:4504]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [36:4504]
-A INPUT -s 3.3.3.3/32 -j ACCEPT
-A INPUT -d 3.3.3.3/32 -p tcp -m tcp --dport 44 -j ACCEPT
COMMIT
# Completed on Sun Feb 20 15:04:36 2011
    """)
    assert repr(ret) == """{'filter': ['-A INPUT -s 3.3.3.3/32 -j ACCEPT', '-A INPUT -d 3.3.3.3/32 -p tcp -m tcp --dport 44 -j ACCEPT'], 'nat': []}""", \
        "Returned: %s" % repr(ret)

def test_parse_iptables_save_3():
    sx = MockSSHConnector(targets={'localhost':['127.0.0.1']})
    ret = sx.parse_iptables_save("""*nat
:PREROUTING ACCEPT [7:600]
:POSTROUTING ACCEPT [987:59895]
:OUTPUT ACCEPT [987:59895]
-A PREROUTING -d 1.2.3.4/32 -p tcp -m tcp --dport 44 -j ACCEPT
COMMIT
*filter
:INPUT ACCEPT [36:4504]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [36:4504]
-A INPUT -d 3.3.3.3/32 -p tcp -m tcp --dport 44 -j ACCEPT
COMMIT""")
    assert repr(ret) == """{'filter': ['-A INPUT -d 3.3.3.3/32 -p tcp -m tcp --dport 44 -j ACCEPT'], 'nat': ['-A PREROUTING -d 1.2.3.4/32 -p tcp -m tcp --dport 44 -j ACCEPT']}""", \
        "Returned: %s" % repr(ret)



@with_setup(setup_dir, teardown_dir)
def test_MockSSHConnector_get_confs():
    sshconn = MockSSHConnector(targets={'localhost':['127.0.0.1']})
    sshconn.repodir = repodir
    d  = sshconn.get_confs( )
    assert 'localhost' in d, repr(d)
    assert 'iptables' in d['localhost'], repr(d)
    assert 'ip_a_s' in d['localhost'], repr(d)
    assert d['localhost'].iptables != None
    assert d['localhost'].ip_a_s != None

    ok = {'localhost': {'iptables': ['# Generated by iptables-save v1.4.8 on Sun Jul  4 09:28:19 2010', '*nat', ':PREROUTING ACCEPT [8:3712]', ':POSTROUTING ACCEPT [32:3081]', ':OUTPUT ACCEPT [32:3081]', '-A POSTROUTING -o eth3 -j MASQUERADE', 'COMMIT', '# Completed on Sun Jul  4 09:28:19 2010', '# Generated by iptables-save v1.4.8 on Sun Jul  4 09:28:19 2010', '*filter', ':INPUT ACCEPT [4304:2534591]', ':FORWARD ACCEPT [0:0]', ':OUTPUT ACCEPT [4589:2195434]', '-A INPUT -s 10.0.0.0/8 -p tcp -m tcp --dport 80 -j ACCEPT', '-A FORWARD -s 1.2.3.4/32 -d 5.6.7.8/32 -p tcp -m multiport --dports 22,80,443 -j ACCEPT', '-A OUTPUT -d 10.10.10.10/32 -p udp -m udp --dport 123 -j ACCEPT', 'COMMIT', '# Completed on Sun Jul  4 09:28:19 2010'], 'ip_a_s': {'lo': ('127.0.0.1/8', '::1/128'), 'wlan0': ('192.168.1.1/24', 'fe80::219:d2ff:fe26:fb8e/64'), 'eth0': (None, None)}}}

    for x in d:
        for y in d[x]:
            assert d[x][y] == ok[x][y], """Incorrect conf retrieved
                \n%s versus\n%s""" % (d[x][y], ok[x][y])
    assert_raises(NotImplementedError,  sshconn._interact, '', 'echo hi')



#def setup_dummy_flssh():
#    """Patch the pxssh module to use files instead of performing network interaction"""
#    import pxssh
#    setup_dir()
#    def dummy_sl(self, a):
#        n = self.my_hostname
#        log.debug( "Sending '%s' to bogus '%s'" % (a, n))
#        if 'save' in a:
#            self.before = open('test/iptables-save-%s' % n).read()
#        else:
#            self.before = open('test/ip-addr-show-%s' % n).read()
#
#    pxssh.login = pxssh.isalive = pxssh.prompt = pxssh.logout = lambda *x: True
#    pxssh.sendline = dummy_sl
#    globals()['pxssh'] = pxssh
#
#def teardown_flssh():
#    teardown_dir()
#
#
#@with_setup(setup_dummy_flssh)
#def test_get_confs_local_dummy():
#    from firelet.flssh import SSHConnector, MockSSHConnector
#
#    sshconn = SSHConnector(targets={'localhost':['127.0.0.1']} )
#    d  = sshconn.get_confs( )
#    assert 'localhost' in d
#    assert d['localhost']
#    assert d == {'localhost': [None, '127.0.0.1', {'filter': '-A INPUT -s 10.0.0.0/8 -p tcp -m tcp --dport 80 -j ACCEPT\n-A FORWARD -s 1.2.3.4/32 -d 5.6.7.8/32 -p tcp -m multiport --dports 22,80,443 -j ACCEPT\n-A OUTPUT -d 10.10.10.10/32 -p udp -m udp --dport 123 -j ACCEPT', 'nat': '-A POSTROUTING -o eth3 -j MASQUERADE'}, {'lo': ('127.0.0.1/8', '::1/128'), 'teredo': (None, 'fe80::ffff:ffff:ffff/64'), 'wlan0': ('192.168.1.1/24', 'fe80::219:d2ff:fe26:fb8e/64'), 'eth0': (None, None)}]}




#@with_setup(setup_dummy_flssh, teardown_dir)
#def test_get_confs3():
#    fs = DumbFireSet(repodir=repodir)
#    fs._get_confs()
#    assert fs._remote_confs == {'Bilbo': [None, '10.66.2.1', {'filter': '-A INPUT -s 10.0.0.0/8 -p tcp -m tcp --dport 80 -j ACCEPT\n-A FORWARD -s 1.2.3.4/32 -d 5.6.7.8/32 -p tcp -m multiport --dports 22,80,443 -j ACCEPT\n-A OUTPUT -d 10.10.10.10/32 -p udp -m udp --dport 123 -j ACCEPT', 'nat': '-A POSTROUTING -o eth3 -j MASQUERADE'}, {'lo': ('127.0.0.1/8', '::1/128'), 'eth1': ('10.66.2.1/24', 'fe80::3939:3939:3939:3939/64'), 'eth0': ('10.66.1.2/24', 'fe80::3939:3939:3939:3939/64')}], 'Fangorn': [None, '10.66.2.2', {'filter': '-A INPUT -s 10.0.0.0/8 -p tcp -m tcp --dport 80 -j ACCEPT\n-A FORWARD -s 1.2.3.4/32 -d 5.6.7.8/32 -p tcp -m multiport --dports 22,80,443 -j ACCEPT\n-A OUTPUT -d 10.10.10.10/32 -p udp -m udp --dport 123 -j ACCEPT', 'nat': '-A POSTROUTING -o eth3 -j MASQUERADE'}, {'lo': ('127.0.0.1/8', '::1/128'), 'eth0': ('10.66.2.2/24', 'fe80::3939:3939:3939:3939/64')}], 'Gandalf': [None, '10.66.1.1', {'filter': '-A INPUT -s 10.0.0.0/8 -p tcp -m tcp --dport 80 -j ACCEPT\n-A FORWARD -s 1.2.3.4/32 -d 5.6.7.8/32 -p tcp -m multiport --dports 22,80,443 -j ACCEPT\n-A OUTPUT -d 10.10.10.10/32 -p udp -m udp --dport 123 -j ACCEPT', 'nat': '-A POSTROUTING -o eth3 -j MASQUERADE'}, {'lo': ('127.0.0.1/8', '::1/128'), 'eth1': ('10.66.1.1/24', 'fe80::3939:3939:3939:3939/64'), 'eth0': ('172.16.2.223/24', 'fe80::3939:3939:3939:3939/64')}], 'Smeagol': [None, '10.66.1.3', {'filter': '-A INPUT -s 10.0.0.0/8 -p tcp -m tcp --dport 80 -j ACCEPT\n-A FORWARD -s 1.2.3.4/32 -d 5.6.7.8/32 -p tcp -m multiport --dports 22,80,443 -j ACCEPT\n-A OUTPUT -d 10.10.10.10/32 -p udp -m udp --dport 123 -j ACCEPT', 'nat': '-A POSTROUTING -o eth3 -j MASQUERADE'}, {'lo': ('127.0.0.1/8', '::1/128'), 'eth0': ('10.66.1.3/24', 'fe80::3939:3939:3939:3939/64')}]}



#@with_setup(setup_dummy_flssh, teardown_dir)
#def test_get_confs4():
#    fs = DumbFireSet(repodir=repodir)
#    fs._get_confs()
#    fs._check_ifaces()
#    rd = fs.compile_dict(hosts=fs.hosts)





def test_clean():
    """Test user input cleanup"""
    s = clean(' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_')
    assert s == ' !#$%&()*+,-./0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_'


# #  User management testing  # #

@with_setup(setup_dir, teardown_dir)
def test_user_management():
    u = Users(d=repodir)
    u.create('Totoro', 'admin', 'rawr', 'totoro@nowhere.forest')
    assert_raises(Exception,  u.create, 'Totoro', '', '', '')
    u.validate('Totoro', 'rawr')
    assert_raises(Exception, u.validate, 'Totoro', 'booo')
    u.update('Totoro', role='user')
    assert u._users['Totoro'][0] == 'user'
    u.update('Totoro', pwd='')
    u.update('Totoro', email='')
    assert u._users['Totoro'][2] == ''
    assert_raises(Exception, u.update, 'Totoro2', 'email=""')
    u.delete('Totoro')
    assert_raises(Exception,  u.delete, 'Totoro')


# # File save/load # #

@with_setup(setup_dir, teardown_dir)
def test_load_save_hosts():
    lines = open(repodir + '/hosts.csv', 'r').readlines()
    content = [x.strip() for x in lines]
    content = filter(None, content)
    h = Hosts(d=repodir)
    h.save()
    lines = open(repodir + '/hosts.csv', 'r').readlines()
    content2 = [x.strip() for x in lines]
    content2 = filter(None, content2)
    h2 = Hosts(d=repodir)
    assert content == content2, "load/save hosts loop failed:\n\n%s\n\n%s\n\n" \
        % (repr(content), repr(content2))
    assert repr(h) == repr(h2), "load/save hosts loop failed"

@with_setup(setup_dir, teardown_dir)
def test_load_save_csv():
    h = loadcsv('rules', d=repodir)
    savecsv('rules', h, d=repodir)
    h2 = loadcsv('rules', d=repodir)
    assert h == h2, "load/save hosts loop failed"

# #  FireSet testing # #

@with_setup(setup_dir, teardown_dir)
def test_gitfireset_simple():
    fs = GitFireSet(repodir=repodir)
    assert fs.save_needed() == False
    fs.save('test')
    assert fs.save_needed() == False
    fs.reset()
    assert fs.save_needed() == False

@with_setup(setup_dir, teardown_dir)
def test_gitfireset_long():
    fs = GitFireSet(repodir=repodir)
    for t in ('rules', 'hosts', 'hostgroups', 'services', 'networks'):
        fs.delete(t, 1)
#        assert fs.save_needed() == True, "save_needed non set when deleting item 1 from %s" % t
        fs.save("%s: n.1 deleted" % t)
        assert fs.save_needed() == False
    fs.rules.moveup(2)
#    assert fs.save_needed() == True
    fs.rules.movedown(1)
    fs.save('movedown1')
    fs.rules.movedown(2)
    fs.save('movedown2')
    fs.rules.movedown(3)
    fs.save('movedown3')
    vl = fs.version_list()
    log.debug('version_list: %s' % repr(vl))
    assert zip(*vl)[2] == (['movedown3'], ['movedown2'], ['networks: n.1 deleted'], ['services: n.1 deleted'],
                            ['hostgroups: n.1 deleted'], ['hosts: n.1 deleted'], ['rules: n.1 deleted'])
    fs.rollback(2)
    assert fs.save_needed() == False
    vl = fs.version_list()
    log.debug('version_list: %s' % repr(vl))
    assert zip(*vl)[2] == (['networks: n.1 deleted'], ['services: n.1 deleted'], ['hostgroups: n.1 deleted'],
                            ['hosts: n.1 deleted'], ['rules: n.1 deleted'])


@with_setup(setup_dir, teardown_dir)
def test_gitfireset_check_ifaces_1():
    fs = GitFireSet(repodir=repodir)
    fs._remote_confs = None
    assert_raises(AssertionError, fs._check_ifaces)

@with_setup(setup_dir, teardown_dir)
def test_gitfireset_check_ifaces_20():
    fs = GitFireSet(repodir=repodir)
    d = {'Bilbo': {'filter': [], 'ip_a_s': {'eth1': ('10.66.2.1/24',None),
                'eth0': ('10.66.1.2/24', None)}},
            'Fangorn': {'filter': [], 'ip_a_s': {'eth0': ('10.66.2.2/24', None)}},
            'Gandalf': {'filter': [], 'ip_a_s': {
                'eth1': ('10.66.1.1/24', None),
                'eth2': ('88.88.88.88/24', None),
                'eth0': ('172.16.2.223/24', None)}},
            'Smeagol': {'filter': [], 'ip_a_s': {'eth0': ('10.66.1.3/24', None)}} }
    fs._remote_confs = {}
    for n, v in d.iteritems():
        fs._remote_confs[n] = Bunch(filter=v['filter'], ip_a_s=v['ip_a_s'])
    fs._check_ifaces()

@with_setup(setup_dir, teardown_dir)
def test_gitfireset_check_ifaces_wrong_value():
    fs = GitFireSet(repodir=repodir)
    fs._remote_confs = {'bogus': 'not a bunch'} # value should be a Bunch
    assert_raises(AssertionError, fs._check_ifaces)

@with_setup(setup_dir, teardown_dir)
def test_gitfireset_check_ifaces_wrong_bunch_size():
    fs = GitFireSet(repodir=repodir)
    fs._remote_confs = {'bogus': Bunch()} # len(Bunch(...)) should be 2 (ip_addr_v4, ip_addr_v6)
    assert_raises(AssertionError, fs._check_ifaces)

@with_setup(setup_dir, teardown_dir)
def test_gitfireset_check_ifaces_missing_iface():
    fs = GitFireSet(repodir=repodir)
    fs.hosts = [
        Bunch(hostname='host1', iface='lo'),
        Bunch(hostname='host2', iface='lo')
    ]
    fs._remote_confs = {
        'host1': Bunch(ip_a_s = {'lo': ()}),
        'host2': Bunch(ip_a_s = {}) # missing iface
    }
    assert_raises(AssertionError, fs._check_ifaces)

@with_setup(setup_dir, teardown_dir)
def test_gitfireset_check_ifaces_wrong_ipaddr_string():
    """_check_ifaces should raise AssertionError on incorrect IPaddr strings"""
    fs = GitFireSet(repodir=repodir)
    fs.hosts = [
        Bunch(hostname='host1', iface='lo'),
        Bunch(hostname='host2', iface='lo')
    ]
    fs._remote_confs = {
        'host1': Bunch(ip_a_s = {'lo': ('bogus', 'bogus')}),
        'host2': Bunch(ip_a_s = {'lo': ('bogus', 'bogus') })
    }
    assert_raises(AssertionError, fs._check_ifaces)

@with_setup(setup_dir, teardown_dir)
def test_gitfireset_check_ifaces_wrong_ipaddr():
    """_check_ifaces should raise AssertionError on incorrect IPaddr"""
    fs = GitFireSet(repodir=repodir)
    fs.hosts = [
        Bunch(hostname='host1', iface='lo', ip_addr='1.2.3.4'),
    ]
    fs._remote_confs = {
        'host1': Bunch(ip_a_s = {'lo': ('1.2.3.5/32', None)}),
    }
    assert_raises(AssertionError, fs._check_ifaces)

@with_setup(setup_dir, teardown_dir)
def test_gitfireset_check_ifaces_correct():
    """_check_ifaces should not raise AssertionError here"""
    fs = GitFireSet(repodir=repodir)
    fs.hosts = [
        Bunch(hostname='host1', iface='lo', ip_addr='1.2.3.4'),
    ]
    fs._remote_confs = {
        'host1': Bunch(ip_a_s = {'lo': ('1.2.3.4/32', None)}),
    }
    assert_raises(AssertionError, fs._check_ifaces)



@with_setup(setup_dir, teardown_dir)
def test_gitfireset_sibling_names():
    fs = GitFireSet(repodir=repodir)
    names = ['AllSystems', 'Bilbo:eth0', 'Bilbo:eth1', 'Clients', 'Fangorn:eth0', 'Gandalf:eth0', \
    'Gandalf:eth1', 'Gandalf:eth2','SSHnodes', 'Servers', 'Smeagol:eth0', 'WebServers']
    assert fs.list_sibling_names() == names, "list_sibling_names generating incorrect output"


#@with_setup(setup_dir, teardown_dir)
#def test_dumbfireset():
#    fs = DumbFireSet(repodir=repodir)
#    assert fs.save_needed() == False
#    fs.save('save')
#    assert fs.save_needed() == False
#    fs.reset()
#    assert fs.save_needed() == False
#    fs.rollback(2)
#    assert fs.save_needed() == False
#    vl = fs.version_list()
#    # assert
#    for t in ('rules', 'hosts', 'hostgroups', 'services', 'networks'):
#        tmp = len(fs.__dict__[t])
#        fs.delete(t, 0)
#        assert fs.save_needed() == True, t
#        assert tmp == len(fs.__dict__[t]) + 1, t
#    fs.save('test')
#    assert fs.save_needed() == False
#    orig_rules = fs.rules[:] # copy
#    fs.rules.moveup(2)
#    assert fs.save_needed() == True
#    assert orig_rules != fs.rules
#    fs.rules.movedown(1)
#    assert orig_rules == fs.rules
#
#    fs.rules.movedown(1)
#    assert orig_rules != fs.rules
#    assert fs.save_needed() == True
#    fs.reset()
#    assert fs.save_needed() == False
#    assert orig_rules == fs.rules





@with_setup(setup_dir, teardown_dir)
def test_DemoGitFireSet_get_confs():
    fs = DemoGitFireSet(repodir=repodir)
    fs._get_confs(keep_sessions=False)
    for hostname, v in fs._remote_confs.iteritems():
        assert isinstance(v, Bunch)
    for h in fs.hosts:
        assert h.hostname in fs._remote_confs, "Missing host %s" % h.hostname



# # Rule compliation and deployment testing # #

@with_setup(setup_dir, teardown_dir)
def test_DemoGitFireSet_compile_rules_basic():
    """Compile rules and perform basic testing"""
    fs = DemoGitFireSet(repodir=repodir)
    rset = fs.compile_rules()
    for hn, d in rset.iteritems():
        for chain,  rules in d.iteritems():
            assert string_in_list('-j DROP', rules), "-j DROP not in %s" % repr(rules)

@with_setup(setup_dir, teardown_dir)
def test_DemoGitFireSet_compile_rules_full():
    fs = GitFireSet(repodir=repodir)
    rd = fs.compile_rules()
    ok = {
      "Bilbo": {
        "FORWARD": [
          "-m state --state RELATED,ESTABLISHED -j ACCEPT",
          "-s 10.66.1.1/32 -d 10.66.2.0/24 -p tcp  -m tcp  --dport 22 -j LOG  --log-prefix \"ssh_mgmt\" --log-level 2",
          "-s 10.66.1.1/32 -d 10.66.2.0/24 -p tcp  -m tcp  --dport 22 -j ACCEPT",
          "-s 10.66.2.2/32 -d 10.66.1.3/32 -p tcp  -m tcp  --dport 6660:6669 -j LOG  --log-prefix \"irc\" --log-level 0",
          "-s 10.66.2.2/32 -d 10.66.1.3/32 -p tcp  -m tcp  --dport 6660:6669 -j ACCEPT",
          "-s 10.66.1.3/32 -d 172.16.2.223/32 -p udp  -m udp  --dport 123 -j LOG  --log-prefix \"ntp\" --log-level 0",
          "-s 10.66.1.3/32 -d 172.16.2.223/32 -p udp  -m udp  --dport 123 -j ACCEPT",
          "-s 10.66.2.2/32 -d 172.16.2.223/32 -p udp  -m udp  --dport 123 -j LOG  --log-prefix \"ntp\" --log-level 0",
          "-s 10.66.2.2/32 -d 172.16.2.223/32 -p udp  -m udp  --dport 123 -j ACCEPT",
          "-s 10.66.2.2/32 -d 10.66.1.3/32 -p udp  -m udp  --dport 123 -j LOG  --log-prefix \"ntp\" --log-level 0",
          "-s 10.66.2.2/32 -d 10.66.1.3/32 -p udp  -m udp  --dport 123 -j ACCEPT",
          " -j LOG  --log-prefix \"default\" --log-level 1",
          " -j DROP",
          " -j LOG  --log-prefix \"default\" --log-level 1",
          " -j DROP"
        ],
        "INPUT": [
          "-m state --state RELATED,ESTABLISHED -j ACCEPT",
          "-i lo -j ACCEPT",
          "-s 10.66.1.1/32 -d 10.66.2.0/24 -i eth1  -p tcp  -m tcp  --dport 22 -j LOG --log-prefix \"ssh_mgmt\" --log-level 2",
          "-s 10.66.1.1/32 -d 10.66.2.0/24 -i eth1  -p tcp  -m tcp  --dport 22 -j ACCEPT",
          "-s 10.66.1.3/32 -d 10.66.1.2/32 -i eth0  -p tcp  -m multiport --dports 143,585,993 -j LOG --log-prefix \"imap\" --log-level 2",
          "-s 10.66.1.3/32 -d 10.66.1.2/32 -i eth0  -p tcp  -m multiport --dports 143,585,993 -j ACCEPT",
          " -i eth0  -j LOG --log-prefix \"default\" --log-level 1",
          " -i eth0  -j DROP",
          " -i eth1  -j LOG --log-prefix \"default\" --log-level 1",
          " -i eth1  -j DROP"
        ],
        "OUTPUT": [
          "-m state --state RELATED,ESTABLISHED -j ACCEPT",
          "-o lo -j ACCEPT",
          "-s 10.66.1.2/32 -d 10.66.1.1/32 -o eth0  -p tcp  -m tcp  --dport 443 -j ACCEPT",
          "-s 10.66.2.1/32 -d 10.66.2.2/32 -o eth1  -p tcp  -m tcp  --dport 80 -j ACCEPT",
          " -o eth0  -j LOG --log-prefix \"default\" --log-level 1",
          " -o eth0  -j DROP",
          " -o eth1  -j LOG --log-prefix \"default\" --log-level 1",
          " -o eth1  -j DROP"
        ]
      },
      "Fangorn": {
        "FORWARD": [
          "-j DROP"
        ],
        "INPUT": [
          "-m state --state RELATED,ESTABLISHED -j ACCEPT",
          "-i lo -j ACCEPT",
          "-s 10.66.2.1/32 -d 10.66.2.2/32 -i eth0  -p tcp  -m tcp  --dport 80 -j ACCEPT",
          "-s 0.0.0.0/0 -d 10.66.2.2/32 -i eth0  -p tcp  -m tcp  --dport 80 -j ACCEPT",
          "-s 10.66.1.1/32 -d 10.66.2.0/24 -i eth0  -p tcp  -m tcp  --dport 22 -j LOG --log-prefix \"ssh_mgmt\" --log-level 2",
          "-s 10.66.1.1/32 -d 10.66.2.0/24 -i eth0  -p tcp  -m tcp  --dport 22 -j ACCEPT",
          " -i eth0  -j LOG --log-prefix \"default\" --log-level 1",
          " -i eth0  -j DROP"
        ],
        "OUTPUT": [
          "-m state --state RELATED,ESTABLISHED -j ACCEPT",
          "-o lo -j ACCEPT",
          "-s 10.66.2.2/32 -d 10.66.1.3/32 -o eth0  -p tcp  -m tcp  --dport 6660:6669 -j ACCEPT",
          "-s 10.66.2.2/32 -d 172.16.2.223/32 -o eth0  -p udp  -m udp  --dport 123 -j ACCEPT",
          "-s 10.66.2.2/32 -d 10.66.1.3/32 -o eth0  -p udp  -m udp  --dport 123 -j ACCEPT",
          " -o eth0  -j LOG --log-prefix \"default\" --log-level 1",
          " -o eth0  -j DROP"
        ]
      },
      "Gandalf": {
        "FORWARD": [
          "-m state --state RELATED,ESTABLISHED -j ACCEPT",
          "-s 10.66.1.3/32 -d 172.16.2.223/32 -p udp  -m udp  --dport 123 -j LOG  --log-prefix \"ntp\" --log-level 0",
          "-s 10.66.1.3/32 -d 172.16.2.223/32 -p udp  -m udp  --dport 123 -j ACCEPT",
          " -j LOG  --log-prefix \"default\" --log-level 1",
          " -j DROP",
          " -j LOG  --log-prefix \"default\" --log-level 1",
          " -j DROP",
          " -j LOG  --log-prefix \"default\" --log-level 1",
          " -j DROP"
        ],
        "INPUT": [
          "-m state --state RELATED,ESTABLISHED -j ACCEPT",
          "-i lo -j ACCEPT",
          "-s 10.66.1.2/32 -d 10.66.1.1/32 -i eth1  -p tcp  -m tcp  --dport 443 -j ACCEPT",
          "-s 10.66.1.3/32 -d 10.66.1.1/32 -i eth1  -j LOG --log-prefix \"NoSmeagol\" --log-level 3",
          "-s 10.66.1.3/32 -d 10.66.1.1/32 -i eth1  -j DROP",
          "-s 10.66.1.3/32 -d 172.16.2.223/32 -i eth0  -p udp  -m udp  --dport 123 -j ACCEPT",
          "-s 10.66.2.2/32 -d 172.16.2.223/32 -i eth0  -p udp  -m udp  --dport 123 -j ACCEPT",
          " -i eth0  -j LOG --log-prefix \"default\" --log-level 1",
          " -i eth0  -j DROP",
          " -i eth1  -j LOG --log-prefix \"default\" --log-level 1",
          " -i eth1  -j DROP",
          " -i eth2  -j LOG --log-prefix \"default\" --log-level 1",
          " -i eth2  -j DROP"
        ],
        "OUTPUT": [
          "-m state --state RELATED,ESTABLISHED -j ACCEPT",
          "-o lo -j ACCEPT",
          "-s 10.66.1.1/32 -d 10.66.2.0/24 -o eth1  -p tcp  -m tcp  --dport 22 -j LOG --log-prefix \"ssh_mgmt\" --log-level 2",
          "-s 10.66.1.1/32 -d 10.66.2.0/24 -o eth1  -p tcp  -m tcp  --dport 22 -j ACCEPT",
          "-s 172.16.2.223/32 -d 10.66.1.3/32 -o eth0  -p udp  -m udp  --dport 123 -j ACCEPT",
          " -o eth0  -j LOG --log-prefix \"default\" --log-level 1",
          " -o eth0  -j DROP",
          " -o eth1  -j LOG --log-prefix \"default\" --log-level 1",
          " -o eth1  -j DROP",
          " -o eth2  -j LOG --log-prefix \"default\" --log-level 1",
          " -o eth2  -j DROP"
        ]
      },
      "Smeagol": {
        "FORWARD": [
          "-j DROP"
        ],
        "INPUT": [
          "-m state --state RELATED,ESTABLISHED -j ACCEPT",
          "-i lo -j ACCEPT",
          "-s 10.66.2.2/32 -d 10.66.1.3/32 -i eth0  -p tcp  -m tcp  --dport 6660:6669 -j ACCEPT",
          "-s 172.16.2.223/32 -d 10.66.1.3/32 -i eth0  -p udp  -m udp  --dport 123 -j ACCEPT",
          "-s 10.66.2.2/32 -d 10.66.1.3/32 -i eth0  -p udp  -m udp  --dport 123 -j ACCEPT",
          " -i eth0  -j LOG --log-prefix \"default\" --log-level 1",
          " -i eth0  -j DROP"
        ],
        "OUTPUT": [
          "-m state --state RELATED,ESTABLISHED -j ACCEPT",
          "-o lo -j ACCEPT",
          "-s 10.66.1.3/32 -d 10.66.1.1/32 -o eth0  -j LOG --log-prefix \"NoSmeagol\" --log-level 3",
          "-s 10.66.1.3/32 -d 10.66.1.1/32 -o eth0  -j DROP",
          "-s 10.66.1.3/32 -d 10.66.1.2/32 -o eth0  -p tcp  -m multiport --dports 143,585,993 -j LOG --log-prefix \"imap\" --log-level 2",
          "-s 10.66.1.3/32 -d 10.66.1.2/32 -o eth0  -p tcp  -m multiport --dports 143,585,993 -j ACCEPT",
          "-s 10.66.1.3/32 -d 172.16.2.223/32 -o eth0  -p udp  -m udp  --dport 123 -j ACCEPT",
          " -o eth0  -j LOG --log-prefix \"default\" --log-level 1",
          " -o eth0  -j DROP"
        ]
      }
    }

    debug('rd', rd)

    for hostname in ok:
        for chain in ok[hostname]:
            for n, my_line in enumerate(rd[hostname][chain]):
                ok_line = ok[hostname][chain][n]
                assert my_line == ok_line, "Incorrect rules in %s chain %s:\ngot:      [%s]\nexpected: [%s]" % (hostname, chain, my_line,  ok_line )

    #FIXME: review rule, ensure they are really correct


@with_setup(setup_dir, teardown_dir)
def test_DemoGitFireSet_build_ipt_restore():
    """Run diff between compiled rules and empty remote confs"""
    fs = DemoGitFireSet(repodir=repodir)
    rset = fs.compile_rules()
    m = map(fs._build_ipt_restore, rset.iteritems())
    m = dict(m)
    ok = {
      "Bilbo": [
        "# Created by Firelet for host Bilbo",
        "*filter",
        "-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT",
        "-A INPUT -i lo -j ACCEPT",
        "-A INPUT -s 10.66.1.1/32 -d 10.66.2.0/24 -i eth1  -p tcp  -m tcp  --dport 22 -j LOG --log-prefix \"ssh_mgmt\" --log-level 2",
        "-A INPUT -s 10.66.1.1/32 -d 10.66.2.0/24 -i eth1  -p tcp  -m tcp  --dport 22 -j ACCEPT",
        "-A INPUT -s 10.66.1.3/32 -d 10.66.1.2/32 -i eth0  -p tcp  -m multiport --dports 143,585,993 -j LOG --log-prefix \"imap\" --log-level 2",
        "-A INPUT -s 10.66.1.3/32 -d 10.66.1.2/32 -i eth0  -p tcp  -m multiport --dports 143,585,993 -j ACCEPT",
        "-A INPUT  -i eth0  -j LOG --log-prefix \"default\" --log-level 1",
        "-A INPUT  -i eth0  -j DROP",
        "-A INPUT  -i eth1  -j LOG --log-prefix \"default\" --log-level 1",
        "-A INPUT  -i eth1  -j DROP",
        "-A FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT",
        "-A FORWARD -s 10.66.1.1/32 -d 10.66.2.0/24 -p tcp  -m tcp  --dport 22 -j LOG  --log-prefix \"ssh_mgmt\" --log-level 2",
        "-A FORWARD -s 10.66.1.1/32 -d 10.66.2.0/24 -p tcp  -m tcp  --dport 22 -j ACCEPT",
        "-A FORWARD -s 10.66.2.2/32 -d 10.66.1.3/32 -p tcp  -m tcp  --dport 6660:6669 -j LOG  --log-prefix \"irc\" --log-level 0",
        "-A FORWARD -s 10.66.2.2/32 -d 10.66.1.3/32 -p tcp  -m tcp  --dport 6660:6669 -j ACCEPT",
        "-A FORWARD -s 10.66.1.3/32 -d 172.16.2.223/32 -p udp  -m udp  --dport 123 -j LOG  --log-prefix \"ntp\" --log-level 0",
        "-A FORWARD -s 10.66.1.3/32 -d 172.16.2.223/32 -p udp  -m udp  --dport 123 -j ACCEPT",
        "-A FORWARD -s 10.66.2.2/32 -d 172.16.2.223/32 -p udp  -m udp  --dport 123 -j LOG  --log-prefix \"ntp\" --log-level 0",
        "-A FORWARD -s 10.66.2.2/32 -d 172.16.2.223/32 -p udp  -m udp  --dport 123 -j ACCEPT",
        "-A FORWARD -s 10.66.2.2/32 -d 10.66.1.3/32 -p udp  -m udp  --dport 123 -j LOG  --log-prefix \"ntp\" --log-level 0",
        "-A FORWARD -s 10.66.2.2/32 -d 10.66.1.3/32 -p udp  -m udp  --dport 123 -j ACCEPT",
        "-A FORWARD  -j LOG  --log-prefix \"default\" --log-level 1",
        "-A FORWARD  -j DROP",
        "-A FORWARD  -j LOG  --log-prefix \"default\" --log-level 1",
        "-A FORWARD  -j DROP",
        "-A OUTPUT -m state --state RELATED,ESTABLISHED -j ACCEPT",
        "-A OUTPUT -o lo -j ACCEPT",
        "-A OUTPUT -s 10.66.1.2/32 -d 10.66.1.1/32 -o eth0  -p tcp  -m tcp  --dport 443 -j ACCEPT",
        "-A OUTPUT -s 10.66.2.1/32 -d 10.66.2.2/32 -o eth1  -p tcp  -m tcp  --dport 80 -j ACCEPT",
        "-A OUTPUT  -o eth0  -j LOG --log-prefix \"default\" --log-level 1",
        "-A OUTPUT  -o eth0  -j DROP",
        "-A OUTPUT  -o eth1  -j LOG --log-prefix \"default\" --log-level 1",
        "-A OUTPUT  -o eth1  -j DROP",
        "COMMIT"
      ],
      "Fangorn": [
        "# Created by Firelet for host Fangorn",
        "*filter",
        "-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT",
        "-A INPUT -i lo -j ACCEPT",
        "-A INPUT -s 10.66.2.1/32 -d 10.66.2.2/32 -i eth0  -p tcp  -m tcp  --dport 80 -j ACCEPT",
        "-A INPUT -s 0.0.0.0/0 -d 10.66.2.2/32 -i eth0  -p tcp  -m tcp  --dport 80 -j ACCEPT",
        "-A INPUT -s 10.66.1.1/32 -d 10.66.2.0/24 -i eth0  -p tcp  -m tcp  --dport 22 -j LOG --log-prefix \"ssh_mgmt\" --log-level 2",
        "-A INPUT -s 10.66.1.1/32 -d 10.66.2.0/24 -i eth0  -p tcp  -m tcp  --dport 22 -j ACCEPT",
        "-A INPUT  -i eth0  -j LOG --log-prefix \"default\" --log-level 1",
        "-A INPUT  -i eth0  -j DROP",
        "-A FORWARD -j DROP",
        "-A OUTPUT -m state --state RELATED,ESTABLISHED -j ACCEPT",
        "-A OUTPUT -o lo -j ACCEPT",
        "-A OUTPUT -s 10.66.2.2/32 -d 10.66.1.3/32 -o eth0  -p tcp  -m tcp  --dport 6660:6669 -j ACCEPT",
        "-A OUTPUT -s 10.66.2.2/32 -d 172.16.2.223/32 -o eth0  -p udp  -m udp  --dport 123 -j ACCEPT",
        "-A OUTPUT -s 10.66.2.2/32 -d 10.66.1.3/32 -o eth0  -p udp  -m udp  --dport 123 -j ACCEPT",
        "-A OUTPUT  -o eth0  -j LOG --log-prefix \"default\" --log-level 1",
        "-A OUTPUT  -o eth0  -j DROP",
        "COMMIT"
      ],
      "Gandalf": [
        "# Created by Firelet for host Gandalf",
        "*filter",
        "-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT",
        "-A INPUT -i lo -j ACCEPT",
        "-A INPUT -s 10.66.1.2/32 -d 10.66.1.1/32 -i eth1  -p tcp  -m tcp  --dport 443 -j ACCEPT",
        "-A INPUT -s 10.66.1.3/32 -d 10.66.1.1/32 -i eth1  -j LOG --log-prefix \"NoSmeagol\" --log-level 3",
        "-A INPUT -s 10.66.1.3/32 -d 10.66.1.1/32 -i eth1  -j DROP",
        "-A INPUT -s 10.66.1.3/32 -d 172.16.2.223/32 -i eth0  -p udp  -m udp  --dport 123 -j ACCEPT",
        "-A INPUT -s 10.66.2.2/32 -d 172.16.2.223/32 -i eth0  -p udp  -m udp  --dport 123 -j ACCEPT",
        "-A INPUT  -i eth0  -j LOG --log-prefix \"default\" --log-level 1",
        "-A INPUT  -i eth0  -j DROP",
        "-A INPUT  -i eth1  -j LOG --log-prefix \"default\" --log-level 1",
        "-A INPUT  -i eth1  -j DROP",
        "-A INPUT  -i eth2  -j LOG --log-prefix \"default\" --log-level 1",
        "-A INPUT  -i eth2  -j DROP",
        "-A FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT",
        "-A FORWARD -s 10.66.1.3/32 -d 172.16.2.223/32 -p udp  -m udp  --dport 123 -j LOG  --log-prefix \"ntp\" --log-level 0",
        "-A FORWARD -s 10.66.1.3/32 -d 172.16.2.223/32 -p udp  -m udp  --dport 123 -j ACCEPT",
        "-A FORWARD  -j LOG  --log-prefix \"default\" --log-level 1",
        "-A FORWARD  -j DROP",
        "-A FORWARD  -j LOG  --log-prefix \"default\" --log-level 1",
        "-A FORWARD  -j DROP",
        "-A FORWARD  -j LOG  --log-prefix \"default\" --log-level 1",
        "-A FORWARD  -j DROP",
        "-A OUTPUT -m state --state RELATED,ESTABLISHED -j ACCEPT",
        "-A OUTPUT -o lo -j ACCEPT",
        "-A OUTPUT -s 10.66.1.1/32 -d 10.66.2.0/24 -o eth1  -p tcp  -m tcp  --dport 22 -j LOG --log-prefix \"ssh_mgmt\" --log-level 2",
        "-A OUTPUT -s 10.66.1.1/32 -d 10.66.2.0/24 -o eth1  -p tcp  -m tcp  --dport 22 -j ACCEPT",
        "-A OUTPUT -s 172.16.2.223/32 -d 10.66.1.3/32 -o eth0  -p udp  -m udp  --dport 123 -j ACCEPT",
        "-A OUTPUT  -o eth0  -j LOG --log-prefix \"default\" --log-level 1",
        "-A OUTPUT  -o eth0  -j DROP",
        "-A OUTPUT  -o eth1  -j LOG --log-prefix \"default\" --log-level 1",
        "-A OUTPUT  -o eth1  -j DROP",
        "-A OUTPUT  -o eth2  -j LOG --log-prefix \"default\" --log-level 1",
        "-A OUTPUT  -o eth2  -j DROP",
        "COMMIT"
      ],
      "Smeagol": [
        "# Created by Firelet for host Smeagol",
        "*filter",
        "-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT",
        "-A INPUT -i lo -j ACCEPT",
        "-A INPUT -s 10.66.2.2/32 -d 10.66.1.3/32 -i eth0  -p tcp  -m tcp  --dport 6660:6669 -j ACCEPT",
        "-A INPUT -s 172.16.2.223/32 -d 10.66.1.3/32 -i eth0  -p udp  -m udp  --dport 123 -j ACCEPT",
        "-A INPUT -s 10.66.2.2/32 -d 10.66.1.3/32 -i eth0  -p udp  -m udp  --dport 123 -j ACCEPT",
        "-A INPUT  -i eth0  -j LOG --log-prefix \"default\" --log-level 1",
        "-A INPUT  -i eth0  -j DROP",
        "-A FORWARD -j DROP",
        "-A OUTPUT -m state --state RELATED,ESTABLISHED -j ACCEPT",
        "-A OUTPUT -o lo -j ACCEPT",
        "-A OUTPUT -s 10.66.1.3/32 -d 10.66.1.1/32 -o eth0  -j LOG --log-prefix \"NoSmeagol\" --log-level 3",
        "-A OUTPUT -s 10.66.1.3/32 -d 10.66.1.1/32 -o eth0  -j DROP",
        "-A OUTPUT -s 10.66.1.3/32 -d 10.66.1.2/32 -o eth0  -p tcp  -m multiport --dports 143,585,993 -j LOG --log-prefix \"imap\" --log-level 2",
        "-A OUTPUT -s 10.66.1.3/32 -d 10.66.1.2/32 -o eth0  -p tcp  -m multiport --dports 143,585,993 -j ACCEPT",
        "-A OUTPUT -s 10.66.1.3/32 -d 172.16.2.223/32 -o eth0  -p udp  -m udp  --dport 123 -j ACCEPT",
        "-A OUTPUT  -o eth0  -j LOG --log-prefix \"default\" --log-level 1",
        "-A OUTPUT  -o eth0  -j DROP",
        "COMMIT"
      ]
    }

    debug('m', m)

    for hostname in m:
        for ok_line, my_line in zip(ok[hostname], m[hostname]):
            assert my_line == ok_line, "Incorrect rule built for %s:\ngot [%s]\nexpected [%s]" % (hostname, my_line,  ok_line )




#@with_setup(setup_dir, teardown_dir)
#def test_DemoGitFireSet_diff_table_simple():
#    """Run diff between compiled rules and empty remote confs"""
#    fs = DemoGitFireSet(repodir=repodir)
#    new_confs = fs.compile_rules()
#    remote_confs = {}
#    dt = fs._diff(remote_confs, new_confs)
#    assert dt == '<p>The firewalls are up to date. No deployment needed.</p>'
    #FIXME:  deployment IS needed


@with_setup(setup_dir, teardown_dir)
def test_DemoGitFireSet_extract_iptables_rules():
    fs = DemoGitFireSet(repodir=repodir)
    fs._get_confs(keep_sessions=False)
    rules_d = fs._extract_ipt_filter_rules(fs._remote_confs)
    for hn, rules in rules_d.iteritems():
        assert len(rules) > 12,  rules
        assert len(rules) < 34,  rules
        for rule in rules:
            assert rule not in ('COMMIT', '*filter', '*nat')

@with_setup(setup_dir, teardown_dir)
def test_DemoGitFireSet_diff_table_generation_1():
    """Test diff with no changes"""
    fs = DemoGitFireSet(repodir=repodir)
    diff_dict = fs._diff({}, {})
    assert diff_dict == {}

@with_setup(setup_dir, teardown_dir)
def test_DemoGitFireSet_diff_table_generation_2():
    """Test diff with no changes"""
    fs = DemoGitFireSet(repodir=repodir)
    diff_dict = fs._diff({'Bilbo':['']}, {'Bilbo':['']})
    assert diff_dict == {}

@with_setup(setup_dir, teardown_dir)
def test_DemoGitFireSet_diff_table_generation_3():
    fs = DemoGitFireSet(repodir=repodir)
    diff_dict = fs._diff({'Bilbo':['old item', 'static item', 'old item2']},
                                   {'Bilbo':['static item', 'new item', 'new item2']})
    assert diff_dict == {'Bilbo': (['new item', 'new item2'], ['old item', 'old item2'])}

@with_setup(setup_dir, teardown_dir)
def test_DemoGitFireSet_diff_table_generation_all_fw_removed():
    """Test diff where all the firewalls has been removed.
    An empty diff should be generated."""
    fs = DemoGitFireSet(repodir=repodir)
    fs._get_confs(keep_sessions=False)
    existing_rules = fs._extract_ipt_filter_rules(fs._remote_confs)
    diff_dict = fs._diff(existing_rules,   {})
    assert diff_dict == {}, "An empty diff should be generated."

@with_setup(setup_dir, teardown_dir)
def test_DemoGitFireSet_diff_table_generation_all_fw_added():
    """Test diff right after all the firewalls has been added.
    An empty diff should be generated."""
    fs = DemoGitFireSet(repodir=repodir)
    fs.save('test') #FIXME: shouldn't be required
    comp_rules = fs.compile_rules()
    new_rules = {}
    for hn, b in comp_rules.iteritems():
        li = fs._build_ipt_restore_blocks((hn, b))
        new_rules[hn] = li
    diff_dict = fs._diff({}, new_rules)
    assert diff_dict == {}, "An empty diff should be generated."


# Used during development with test/rebuild.sh #
# to generate new sets of  test files #
#
#@with_setup(setup_dir, teardown_dir)
#def test_DemoGitFireSet_rebuild():
#    fs = DemoGitFireSet(repodir=repodir)
#    comp_rules = fs.compile_rules()
#    for hn, b in comp_rules.iteritems():
#        li = fs._build_ipt_restore((hn, b))[1]
#        open("test/new-iptables-save-%s" % hn, 'w').write('\n'.join(li)+'\n')


@with_setup(setup_dir, teardown_dir)
def test_DemoGitFireSet_check():
    """Run diff between complied rules and remote confs using DemoGitFireSet
    Given the test files, the check should be ok and require no deployment"""
    fs = DemoGitFireSet(repodir=repodir)
    fs.save('test') #FIXME: shouldn't be required
    diff_dict = fs.check()
    assert diff_dict == {},  repr(diff_dict)[:300]

    #FIXME: enable the test again






@with_setup(setup_dir, teardown_dir)
def test_DemoGitFireSet_deploy():
    """Run diff between complied rules and remote confs.
    Given the test files, the check should be ok and require no deployment"""
    fs = DemoGitFireSet(repodir=repodir)
    log.debug("Test deployment in %s" % repodir)
    fs.deploy()
    for h in fs.hosts:
        ok = open(repodir + '/iptables-save-%s' % h.hostname).readlines()
        r = open(repodir + '/iptables-save-%s-x' % h.hostname).readlines()
        assert ok == r
        #debug('r', r)
        #debug('ok', ok)

@with_setup(setup_dir, teardown_dir)
def test_DemoGitFireSet_deploy_then_check():
    """Deploy conf then run check again"""
    fs = DemoGitFireSet(repodir=repodir)
    log.debug("Running deployment using repository in %s" % repodir)
    fs.save('test') #FIXME: shouldn't be required
    fs.deploy()
    log.debug("Running check...")

    fs.save('test') #FIXME: shouldn't be required
    diff_dict = fs.check()
    assert diff_dict == {},  repr(diff_dict)[:300]



#@with_setup(setup_dir, teardown_dir)
#def test_GitFireSet_deployment():
#    fs = GitFireSet(repodir=repodir)
#    fs.deploy()

#@with_setup(setup_dir, teardown_dir)
#def test_DemoGitFireSet_deploy():
#    fs = DemoGitFireSet(repodir=repodir)
#    dt = fs.deploy()
#    for h in fs.hosts:
#        r = map(str.rstrip, open(repodir + '/iptables-save-%s' % h.hostname))
#        ok = map(str.rstrip, open(repodir + '/iptables-save-%s-correct' % h.hostname))
#        for a, b in zip(r, ok):
#            assert a == b, "%s differs from %s in iptables-save-%s" % (a, b, h.hostname)
#
#

#@with_setup(setup_dummy_flssh)
#def test_get_confs_local_dummy():
#    from firelet.flssh import SSHConnector, MockSSHConnector
#
#    sshconn = SSHConnector(targets={'localhost':['127.0.0.1']} )
#    d  = sshconn.get_confs( )
#    assert 'localhost' in d
#    assert d['localhost']
#    assert d == {'localhost': [None, '127.0.0.1', {'filter': '-A INPUT -s 10.0.0.0/8 -p tcp -m tcp --dport 80 -j ACCEPT\n-A FORWARD -s 1.2.3.4/32 -d 5.6.7.8/32 -p tcp -m multiport --dports 22,80,443 -j ACCEPT\n-A OUTPUT -d 10.10.10.10/32 -p udp -m udp --dport 123 -j ACCEPT', 'nat': '-A POSTROUTING -o eth3 -j MASQUERADE'}, {'lo': ('127.0.0.1/8', '::1/128'), 'teredo': (None, 'fe80::ffff:ffff:ffff/64'), 'wlan0': ('192.168.1.1/24', 'fe80::219:d2ff:fe26:fb8e/64'), 'eth0': (None, None)}]}





# #  IP address handling  # #


def test_network_update():
    assert Network(['','255.255.255.255',8]).ip_addr == '255.0.0.0'
    assert Network(['','255.255.255.255',16]).ip_addr == '255.255.0.0'
    assert Network(['','255.255.255.255',24]).ip_addr == '255.255.255.0'
    assert Network(['','255.255.255.255',27]).ip_addr == '255.255.255.224'
    assert Network(['','255.255.255.255',28]).ip_addr == '255.255.255.240'
    assert Network(['','255.255.255.255',29]).ip_addr == '255.255.255.248'
    assert Network(['','255.255.255.255',30]).ip_addr == '255.255.255.252'


def test_contains_nets():
    assert Network(['', '255.255.255.255', 16]) in Network(['', '255.255.255.255', 8])
    assert Network(['', '255.255.255.255', 16]) in Network(['', '255.255.255.255', 16])
    assert Network(['', '255.255.255.255', 8]) not in Network(['', '255.255.255.255', 16])
    assert Network(['', '1.0.0.0', 17]) in Network(['', '1.0.0.0', 16])
    assert Network(['', '1.0.0.0', 16]) in Network(['', '1.0.0.0', 16])
    assert Network(['', '1.0.0.0', 15]) not in Network(['', '1.0.0.0', 16])
    assert Network(['', '42.42.42.42', 15]) not in Network(['','42.42.42.42', 16])
    assert Network(['', '42.42.42.42', 16]) in Network(['','42.42.42.42', 16])
    assert Network(['', '42.42.42.42', 17]) in Network(['','42.42.42.42', 16])

def test_contain_hosts():
    assert Host(['h', 'eth0', '1.1.1.1', 24, '1', '1', '1', [] ]) \
        in Network(['h', '1.1.1.0', 28])
    assert Host(['h', 'eth0', '1.1.1.15',24, '1', '1', '1', [] ]) \
        in Network(['h', '1.1.1.0', 28])
    assert Host(['h', 'eth0', '1.1.1.16',24, '1', '1', '1', [] ]) \
        not in Network(['h', '1.1.1.0', 28])
    assert Host(['h', 'eth0', '1.1.1.1',24, '1', '1', '1', [] ]) \
        in Network(['h', '1.1.1.0', 24])
    assert Host(['h', 'eth0', '1.1.1.1',24, '1', '1', '1', [] ]) \
        in Network(['h', '1.1.1.0', 8])
    assert Host(['h', 'eth0', '1.1.1.1',24, '1', '1', '1', [] ]) \
        not in Network(['h', '1.1.2.0', 24])
    assert Host(['h', 'eth0', '1.1.1.1',24, '1', '1', '1', [] ]) \
        not in Network(['h', '10.1.1.0', 8])

def test_compare():
    from netaddr import IPNetwork
    for x in xrange(0, 32):
        n=IPNetwork('255.1.1.1/%d' % x)
        ok = n.network
        mine = Network(['','255.1.1.1', x]).ip_addr
        log.debug( 'ok: %s mine: %s len: %d' % (ok,  mine, x))
        assert str(mine) == str(ok)


#def test_flattening():
#    hg2 = HostGroup(['name', [Host(['h', 'eth0', '1.1.1.1',24, '1', '1', '1', [] ])], ])
#    hg3 = HostGroup(['name2', [Network(['n', '2.2.2.0', 24]), hg2]])
#    hg = HostGroup(childs=[hg2, hg3])
#    assert ['h', 'h'] == [h.hostname for h in hg.hosts()]
#    assert ['n'] == [h.name for h in hg.networks()], repr(hg.networks())





@with_setup(setup_dir, teardown_dir)
def test_svg_map():
    fs = GitFireSet(repodir=repodir)
    svg = draw_svg_map(fs)
    assert 'DOCTYPE svg PUBLIC' in svg, "No SVG output?"
    assert 'rivendell' in svg, "No rivendell in the map"


# #  CLI testing # #


class MockSay():
    """Mock the say() method in cli.py to store what is being printed"""
    def __init__(self):
        self.li = []
    def __call__(self, s):
        self.li.append(s)
    def hist(self):
        return '\n-----\n' + '\n'.join(self.li) + '\n-----\n'
    def flush(self):
        self.li = []

def mock_open_fs():
    "Testing is performed against the Demo FireSet" #FIXME: use test directory
    return DemoGitFireSet()

def mock_getpass(s=None):
    """Mock getpass() to unit-test user creation"""
    return "12345"

def cli_setup():
    cli.say = MockSay()
    cli.getpass = mock_getpass
    setup_dir()

def cli_run(*args):
    """Wrap CLI invocation to prevent os.exit() from breaking unit testing"""
    a = list(args)
    hist_len = len(cli.say.li)
    assert_raises(SystemExit, cli.main, a), "Exited without 0 or 1" + cli.say.hist()
    return cli.say.li[hist_len:]

@with_setup(cli_setup)
def test_cli_rule_list():
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, 'rule', 'list')
    assert len(cli.say.li) > 5, cli.say.hist()

@with_setup(cli_setup)
def test_cli_help():
    assert_raises(SystemExit, cli.main), "Exit 1, print help"

@with_setup(cli_setup)
def test_cli_list():
    for x in ('rule', 'host', 'hostgroup', 'service', 'network'):
        print "Running cli %s list" % x
        out = cli_run(x, 'list', '')
        assert len(out) > 3, \
            "Short or no output from cli %s list: %s" % (x, repr(out))

@with_setup(cli_setup)
def test_cli_versioning():
    """Versioning functional testing"""
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir,
        '-r '+repodir, 'save_needed', '-q')
    assert out == ['No'], "No save needed here" + cli.say.hist()
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, 'version',
        'list', '-q') # no versions
    assert out == [], "No versions expected" + cli.say.hist()
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, 'rule',
    'disable', '2', '-q')
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, 'save',
    'test1', '-q') # save 1
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, 'version',
                   'list', '-q')
    assert cli.say.li[:3] == ['No', 'Rule 2 disabled.',
    'Configuration saved. Message: "test1"'], "Incorrect behavior"
    assert out[-1].endswith('| test1 |'), cli.say.hist()
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, 'rule',
    'enable', '2', '-q')
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, 'save',
    'test2', '-q') # save 2
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, 'version',
    'list', '-q')
    assert out[-2].endswith('| test2 |'), cli.say.hist()
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, 'rule',
    'disable', '2', '-q')
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, 'save',
    'test3', '-q') # save 1
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, 'version',
    'list', '-q')
    assert out[-3].endswith('| test3 |'), cli.say.hist()
    # rollback by number
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, 'version', 'rollback', '1', '-q')
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, 'version',
    'list', '-q')
    assert out[0].endswith('| test2 |') and \
        out[1].endswith('| test1 |'), "Incorrect rollback" + cli.say.hist()
    # rollback by ID
    commit_id = out[1].split()[0]
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, 'version', 'rollback', commit_id, '-q')
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, 'version',
                   'list', '-q')
    assert out[0].endswith('| test1 |'),  "Incorrect rollback" + cli.say.hist()
    # reset
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, 'rule',
                   'enable', '2', '-q')
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, 'save_needed',
                   '-q')
    assert out[-1] == 'Yes', "Save needed here" + cli.say.hist()
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, 'reset', '-q')
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, 'save_needed',
                   '-q')
    assert out[-1] == 'No', "No save needed here" + cli.say.hist()

# TODO: add check, compile and deploy tests

# CLI user management

@with_setup(cli_setup)
def test_cli_user_management():
    out1 = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, '-q', 'user',
                    'list')
    assert out1 == [
        u'Rob            readonly        None',
        u'Eddy           editor          None',
        u'Ada            admin           None'], \
        "Incorrect user list: %s" % repr(out1) + cli.say.hist()
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, '-q', 'user',
                   'add', 'Totoro',
        'admin', 'totoro@nowhere.forest')
    out2 = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, '-q', 'user',
    'list')
    assert out2 == [
        u'Rob            readonly        None',
        u'Ada            admin           None',
        u'Eddy           editor          None',
        u'Totoro         admin           totoro@nowhere.forest'], \
        "Incorrect user list" + cli.say.hist()
    cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, '-q', 'user',
             'validatepwd', 'Totoro')
    cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, '-q', 'user',
    'del', 'Totoro')
    out3 = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, '-q',
    'user', 'list')
    assert out3 == out1, "User not deleted" + cli.say.hist()

    #TODO: add user editing to the CLI and test it ?

# CLI rule management

@with_setup(cli_setup)
def test_cli_rule_list():
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, '-q',
    'rule', 'list')
    for line in out[1:]:
        li = line.split('|')
        li = map(str.strip, li)
        assert li[1] in ('ACCEPT','DROP'), li
        assert li[5] in ('0','1'), li #en/dis-abled

@with_setup(cli_setup)
def test_cli_rule_enable_disable():
    out1 = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, '-q',
    'rule', 'list')
    assert out1[2].split('|')[5].strip() == '1',  "First rule should be enabled"
    cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, '-q', 'rule',
    'disable', '1')
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, '-q',
    'rule', 'list')
    assert out[2].split('|')[5].strip() == '0',  "First rule should be disabled"
    cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, '-q', 'rule',
    'enable', '1')
    out = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, '-q',
    'rule', 'list')
    assert out == out1, "Rule enable/disable not idempotent"

@with_setup(cli_setup)
def test_cli_multiple_list_and_deletion():
    for name in ('rule', 'host', 'hostgroup', 'network', 'service'):
        before = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, '-q',
                         name, 'list')
        cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, '-q', name,
        'del', '2')
        after = cli_run('-c test/firelet_test.ini',  "-r %s" % repodir, '-q',
                        name, 'list')
        assert len(after) == len(before) - 1, "%s not deleted %s" % \
            (name, cli.say.hist())

# #  Test JSON lib  # #

def json_loop(obj):
    return json.loads(json.dumps(obj, sort_keys=True))

def test_json1():
    d = {'string':'string', 's2':6, 's3':7.7, 's4':True, 's5':False}
    assert d == json_loop(d)

def test_json2():
    d = {'string':'string', 's2':6, 's3':7, 's4':True, 's5':False}
    assert d == json_loop(d)
    assert json.dumps(d) == """{"s3": 7, "s2": 6, "string": "string", \
"s5": false, "s4": true}"""

def test_json3():
    d = {'d1':{'d2':{'d3':{'d4':{'d5':{'this is getting':'boring'}}}}}}
    assert d == json_loop(d)
    assert json.dumps(d) == """{"d1": {"d2": {"d3": {"d4": {"d5": \
{"this is getting": "boring"}}}}}}"""

def test_json4():
    d = [x for x in xrange(42)]
    assert d == json_loop(d)

def test_json5():
    """Keys are casted to strings, integers are not preserved"""
    d = {1:1, 2:2, 3:3}
    assert d != json_loop(d)

@with_setup(setup_dir)
def test_json_files():
    d = {'d1':{'d2':{'d3':{'d4':{'d5':{'this is getting':'boring'}}}}}}
    savejson('jfile', d, d=repodir)
    nd = loadjson('jfile', d=repodir)
    assert d == nd

# #  Test cartesian product  # #

def test_product_2_6():
    from itertools import product

    assert tuple(product([1,2,3,4,5,'O HI'],['a','b','c','d',42])) == (
        (1, 'a'), (1, 'b'), (1, 'c'), (1, 'd'), (1, 42), (2, 'a'), (2, 'b'), (2, 'c'), (2, 'd'), (2, 42),
        (3, 'a'), (3, 'b'), (3, 'c'), (3, 'd'), (3, 42), (4, 'a'), (4, 'b'), (4, 'c'), (4, 'd'), (4, 42),
        (5, 'a'), (5, 'b'), (5, 'c'), (5, 'd'), (5, 42), ('O HI', 'a'), ('O HI', 'b'), ('O HI', 'c'),
        ('O HI', 'd'), ('O HI', 42))


def test_product_2_5():

    def product(*args, **kwds):
        """List cartesian product - not available in Python 2.5"""
        pools = map(tuple, args) * kwds.get('repeat', 1)
        result = [[]]
        for pool in pools:
            result = [x+[y] for x in result for y in pool]
        for prod in result:
            yield tuple(prod)

    assert tuple(product([1,2,3,4,5,'O HI'],['a','b','c','d',42])) == (
        (1, 'a'), (1, 'b'), (1, 'c'), (1, 'd'), (1, 42), (2, 'a'), (2, 'b'), (2, 'c'), (2, 'd'), (2, 42),
        (3, 'a'), (3, 'b'), (3, 'c'), (3, 'd'), (3, 42), (4, 'a'), (4, 'b'), (4, 'c'), (4, 'd'), (4, 42),
        (5, 'a'), (5, 'b'), (5, 'c'), (5, 'd'), (5, 42), ('O HI', 'a'), ('O HI', 'b'), ('O HI', 'c'),
        ('O HI', 'd'), ('O HI', 42))


# #  Bunch objects testing  # #

# Service bunch

def test_bunch_service1():
    d = dict(name='s1', protocol='NotAProtocol', ports='53')
    assert_raises(Exception, Bunch, d)

def test_bunch_service1b():
    d = dict(name='s1', protocol='TCP', ports='53')
    s = Bunch(**d)
    assert s.protocol == 'TCP'

def test_bunch_service2():
    d = dict(name='s1', protocol='TCP', ports='999999')
    assert_raises(Exception, Bunch, d)

def test_bunch_service3():
    d = dict(name='s1', protocol='TCP', ports='-1')
    assert_raises(Exception, Bunch, d)

def test_bunch_service4():
    d = dict(name='s1', protocol='TCP', ports='10:20:30')
    assert_raises(Exception, Bunch, d)

def test_bunch_service5():
    d = dict(name='s1', protocol='TCP', ports='30:20')
    assert_raises(Exception, Bunch, d)

def test_bunch_service6():
    d = dict(name='s1', protocol='TCP', ports='blah')
    assert_raises(Exception, Bunch, d)

def test_bunch_service7():
    d = dict(name='s1', protocol='TCP', ports='80')
    s = Bunch(**d)
    d = dict(name='s1', protocol='TCP', ports='blah')
    s.update(d) #FIXME: this should raise an Alert
    assert s.ports == 'blah'    # remove after the fix
#    assert_raises(Exception, s.update, d)

def test_bunch_service():
    s = Bunch(name='s1', protocol='UDP', ports='53')
    assert s.name == 's1', 'Incorrect bunch name'
    assert s.protocol == 'UDP', 'Incorrect bunch proto'
    assert s.ports == '53', 'Incorrect bunch ports'
    s.update({'name': 's2', 'protocol':'TCP', 'ports':'80'})
    assert s.name == 's2', 'Incorrect bunch name'
    assert s.protocol == 'TCP', 'Incorrect bunch proto'
    assert s.ports == '80', 'Incorrect bunch ports'
#    assert_raises(Alert, s.update,
#        {'name': 's2', 'protocol':'TCP', 'ports':'eighty    '}
#    )



# HostGroup Bunch

def test_bunch_hostgroup1():
    hg = HostGroup(['Servers'])
    assert hg.name == 'Servers'

def test_bunch_hostgroup2():
    hg = HostGroup(['Servers', 'a', 'b'])
    assert hg.childs == ['a', 'b']

#def test_bunch_hostgroup_flatten1():
#    hg = HostGroup(['Servers'])
#    dicts = [{}, {}, {}]
#    assert_raises(Exception, hg.flat, *dicts)

#def test_bunch_hostgroup_flatten2():
#    hg = HostGroup(['Servers'])
#    flat = hg.flat({'Servers':'a'}, {}, {})
#    print flat

#    dicts = [{}, {}, {}]
#    assert_raises(Exception, hg.flat, *dicts)


# Basic Bunch class

def test_bunch_repr():
    b = Bunch( c=42, a=3, b='44', _a=0)
    assert repr(b) == "{'a': 3, 'c': 42, 'b': '44', '_a': 0}", "Bunch repr is incorrect: %s" % repr(b)

def test_bunch_set_get():
    b = Bunch( c=42, a=3, b='44', _a=0)
    assert b.c == 42
    assert b['c'] == 42
    b.c = 17
    assert b.c == 17
    b['c'] = 18
    assert b.c == 18
    assert 'c' in b

def test_bunch_token():
    b = Bunch( c=42, a=3, b='44', _a=0)
    tok = b._token()
    b.validate_token(tok)
    assert_raises(Exception,  b.validate_token, '123456')

def test_bunch_update():
    b = Bunch( c=42, a=3, b='44', _a=0)
    d = dict(_a=1, a=2, b=3, c=4, extra=5)
    b.update(d)
    assert b.a == 2 and b.c == 4

def test_flag_true():
    for x in (1, True, '1', 'True', 'y', 'on' ):
        assert flag(x) == '1'

def test_flag_false():
    for x in (0, False, '0', 'False', 'n', 'off', ''):
        assert flag(x) == '0'

def test_flag_raise():
    for x in ('true', 'false'):
        assert_raises(Exception, flag, x)

# RSS generation
rss_msg = []
def setup_rss():
    from datetime import datetime
    global rss_msg
    rss_msg = [
        ['success', datetime(2011,01,01,10,10,10), 'Blah'],
        ['success', datetime(2011,01,01,10,10,20), 'Configuation saved: line'],
        ['success', datetime(2011,01,01,10,10,30), 'Configuration deployed.'],
    ]

@with_setup(setup_rss)
def test_get_rss_messages():
    d = get_rss_channels('messages', 'url', msg_list=rss_msg)
    assert 'items' in d
    items = d['items']
    assert len(items) == 3

@with_setup(setup_rss)
def test_get_rss_confsaves():
    d = get_rss_channels('confsaves', 'url', msg_list=rss_msg)
    assert 'items' in d
    items = d['items']
    assert len(items) == 1

@with_setup(setup_rss)
def test_get_rss_deployments():
    d = get_rss_channels('deployments', 'url', msg_list=rss_msg)
    assert 'items' in d
    items = d['items']
    assert len(items)
    assert 'title' in items[-1]
    assert 'Firelet success: Configuration deployed.' in items[-1]['title']

